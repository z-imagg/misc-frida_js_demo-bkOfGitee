// 导入 _msic_util.ts
//MyTsCRst//_replaceCurLineByTsFileContent("./_msic_util.ts" , curNextLn)
// [依赖] : 无
function baseNameOfFilePath(filePath) {
    // const filePath = '/app/qemu/build-v8.2.2/qemu-system-x86_64';
    const parts = filePath.split('/');
    const baseName = parts[parts.length - 1];
    // console.log(baseName); 
    return baseName;
}
function nowTxt() {
    const now = new Date();
    //时区没生效，暂时忽略
    const localNowTxt = now.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', });
    const txt = `${now.getTime()},${localNowTxt}`;
    return txt;
}
function isNil(x) {
    const empty = (x == undefined || x == null);
    return empty;
}
function adrToHex(fnAdr) {
    return fnAdr.toString(16);
}
// 以命令MyTsCmd从配置文件config.json读取应用程序名 填充到下一行
//MyTsCRst//_replaceSubStrInNextLine('{}' ,  readTxtFile("./config.json") , curNextLn )
const g_cfg = {
    "appPath": "/fridaAnlzAp/frida_js_demo/app.elf",
    "appArgLsAsTxt": "arg1 2 arg3"
};
const g_appPath = g_cfg["appPath"];
const g_appArgLsAsTxt = g_cfg["appArgLsAsTxt"];
const g_appName = baseNameOfFilePath(g_appPath);
// 以命令MyTsCmd导入文件 _DateTime_util.ts
//MyTsCRst//_replaceCurLineByTsFileContent("./_DateTime_util.ts" , curNextLn)
// [依赖] : 无
function get_now_ms() {
    const now_dt = new Date();
    const abs_ms = now_dt.getTime();
    return abs_ms;
}
//脚本启动时的绝对毫秒数
const g_tsBeginDtMs = get_now_ms();
// 以命令MyTsCmd导入文件 _logFile.ts
//MyTsCRst//_replaceCurLineByTsFileContent("./_logFile.ts" , curNextLn)
// [依赖] : _DateTime_util.ts
const g_logFPath = `./InterceptFnSym-${g_appName}-${g_tsBeginDtMs}.log`;
const g_logF = new File(g_logFPath, "w");
function logWriteLn(txt) {
    const lineTxt = `${txt}\n`;
    g_logF.write(lineTxt);
}
//填充函数符号表格
function findFnDbgSym(fnAdr) {
    const fnSym = DebugSymbol.fromAddress(fnAdr);
    return fnSym;
}
/** onEnter ， 函数进入
 */
function OnFnEnterBusz(thiz, args) {
    const curThreadId = Process.getCurrentThreadId();
    const fnAdr = thiz.context.pc;
    const fnSym = findFnDbgSym(fnAdr);
    logWriteLn(`[OnFnEnterBusz],fnSym=[${fnSym}]`);
    thiz.fnAdr_OnFnEnterBusz = fnAdr;
}
// 以命令MyTsCmd导入文件 _tool.ts
//MyTsCRst//_replaceCurLineByTsFileContent("./_tool.ts" , curNextLn)
// [依赖] : 无
//{4字节对齐 工具函数
function is4times(n) {
    const is_ = Math.floor(n / 4) * 4 == n;
    return is_;
}
function near4times(n) {
    const near = Math.floor((n + (4 - 1)) / 4) * 4;
    return near;
}
//持有本地函数
let g_nativeFn__func01_return_int;
function demo_call_nativeFn_func01() {
    //调用本地函数 func01_return_int
    if (g_nativeFn__func01_return_int) {
        const ret_int = g_nativeFn__func01_return_int(32, -33); //结果应该是-9
        logWriteLn(`[nativeFn__func01_return_int],ret_int=[${ret_int}]`);
    }
} //end of OnFnLeaveBusz
function get__func01_return_int() {
    //获取本地函数func01_return_int
    const func01_return_int = DebugSymbol.fromName("func01_return_int").address;
    g_nativeFn__func01_return_int = new NativeFunction(func01_return_int, 'int', ['char', 'double']);
    logWriteLn(`##nativeFn__func01_return_int=${g_nativeFn__func01_return_int}`);
}
// 以命令MyTsCmd导入文件 _nativeFn_func03.ts
//MyTsCRst//_replaceCurLineByTsFileContent("./_nativeFn_func03.ts" , curNextLn)
// [依赖] : 无
// [描述] 描述 本地函数 func04_retVoid_outArgCharBuffer
//{结构体 'struct T_User'
const _C_Lang__sizeof_short = 2; // sizeof(short)
//short字段 需 对齐到4字节
const C_Lang__sizeof_short = is4times(_C_Lang__sizeof_short) ? _C_Lang__sizeof_short : near4times(_C_Lang__sizeof_short);
logWriteLn(`C_Lang__sizeof_short=${C_Lang__sizeof_short}`);
const C_Lang__sizeof_float = 4; // sizeof(float)
const C_Lang__sizeof_int = 4; // sizeof(int)
let C_Lang__sizeof_structTUser = C_Lang__sizeof_short + C_Lang__sizeof_float + C_Lang__sizeof_int;
// ts的类Struct_TUser 表示 c结构体'struct T_User'
class Struct_TUser {
    //将c结构体'struct T_User'转为ts的类Struct_TUser
    constructor(outArg_ptrStructUsr) {
        //结构体的第1个字段 'short userId' 指针
        const ptr_filed_userId = outArg_ptrStructUsr.add(0);
        //结构体的第2个字段 'float salary' 指针
        const ptr_filed_salary = ptr_filed_userId.add(C_Lang__sizeof_short);
        //结构体的第3个字段 'int sum' 指针
        const ptr_filed_sum = ptr_filed_salary.add(C_Lang__sizeof_float);
        //结构体的第1个字段   userId
        this.userId = ptr_filed_userId.readShort();
        //结构体的第2个字段   salary 
        this.salary = ptr_filed_salary.readFloat();
        //结构体的第3个字段   sum 
        this.sum = ptr_filed_sum.readInt();
    }
}
//}
//frida中表达 函数 func03_retVoid_outArgPtrStructUser 的签名
// void func03_retVoid_outArgPtrStructUser(int _userId, char sex, struct T_User* outArg_ptrStructUsr)
//持有本地函数
let nativeFn__func03_retVoid_outArgPtrStructUser;
//获取 本地函数 func03_retVoid_outArgPtrStructUser
function get__func03_retVoid_outArgPtrStructUser() {
    //获取 本地函数 func03_retVoid_outArgPtrStructUser
    const func03_retVoid_outArgPtrStructUser = DebugSymbol.fromName("func03_retVoid_outArgPtrStructUser").address;
    nativeFn__func03_retVoid_outArgPtrStructUser = new NativeFunction(func03_retVoid_outArgPtrStructUser, 'void', ['int', 'char', 'pointer']); //函数返回类型中无法表达 自定义结构体 T_User, 因此只能用 指针参数携带返回结构体
    /* frida网站 2019年 有人提出了改进需求 将    "C structs" 和  JavaScript objects 做对应 ，但该需求始终是Open的， 这说明frida目前无法调用 调用返回类型为 结构体的本地c函数
    Map between "C structs" and JavaScript objects #1099
  https://github.com/frida/frida/issues/1099
  
    */
    logWriteLn(`##nativeFn__func03_retVoid_outArgPtrStructUser=${nativeFn__func03_retVoid_outArgPtrStructUser}`);
}
/**  调用本地函数 func03 例子
 */
function demo_call_nativeFn_func03() {
    //调用本地函数 func03_retVoid_outArgPtrStructUser
    if (nativeFn__func03_retVoid_outArgPtrStructUser.toInt32() != NULL_num) {
        const outArg_ptrStructUsr = Memory.alloc(C_Lang__sizeof_structTUser);
        //指针参数outArg_ptrStructUsr携带返回结构体
        nativeFn__func03_retVoid_outArgPtrStructUser.call(null, 4, M_ascii, outArg_ptrStructUsr);
        //将c结构体'struct T_User'转为ts的类Struct_TUser
        const retStructTUser = new Struct_TUser(outArg_ptrStructUsr);
        logWriteLn(`[outArg_ptrStructUsr],{userId=${retStructTUser.userId},salary=${retStructTUser.salary}, sum=${retStructTUser.sum} }`);
        // {userId=204,salary=3000.10009765625, sum=-123 }, 结果正确
    }
}
// 以命令MyTsCmd导入文件 _nativeFn_func04.ts
//MyTsCRst//_replaceCurLineByTsFileContent("./_nativeFn_func04.ts" , curNextLn)
// [依赖] : 无
// [描述] 描述 本地函数 func04_retVoid_outArgCharBuffer
//frida中表达 函数 func04_retVoid_outArgCharBuffer 的签名
// int func04_retVoid_outArgCharBuffer(double _doubleNum, long _longInt, char* outArg_CharBuffer)
//持有本地函数
let nativeFn__func04_retVoid_outArgCharBuffer;
//获取 本地函数 func04_retVoid_outArgCharBuffer
function get__func04_retVoid_outArgCharBuffer() {
    const func04_retVoid_outArgCharBuffer = DebugSymbol.fromName("func04_retVoid_outArgCharBuffer").address;
    // int func04_retVoid_outArgCharBuffer(double _doubleNum, long _longInt, char* outArg_CharBuffer)
    nativeFn__func04_retVoid_outArgCharBuffer = new NativeFunction(func04_retVoid_outArgCharBuffer, 'int', ['double', 'long', 'pointer']);
}
const _Concat_Limit = 50;
const _Concat_CntTop = 4;
const _Buffer_Limit = _Concat_CntTop * _Concat_Limit;
// frida中的alloc内存会被垃圾回收, 理论上不必作为全局量，但写作全局变量更合理？
const outArg_CharBuffer = Memory.alloc(_Buffer_Limit);
const _OK = 0;
const NULL_num = NULL.toInt32();
/**  调用本地函数 func04 例子
 */
function demo_call_nativeFn_func04() {
    //调用本地函数 func04_retVoid_outArgCharBuffer
    if (nativeFn__func04_retVoid_outArgCharBuffer.toInt32() != NULL_num) {
        //指针参数outArg_CharBuffer携带返回字符串
        //     int func04_ret_code=func04_retVoid_outArgCharBuffer(4.0, 17, CharBuffer);
        //第1次调用
        let func04_ret_code = nativeFn__func04_retVoid_outArgCharBuffer(4.0, 17, outArg_CharBuffer);
        logWriteLn(`[调用1] func04_ret_code=${func04_ret_code}`);
        // [调用1] func04_ret_code=0
        if (func04_ret_code == _OK) {
            const ret_cstr = outArg_CharBuffer.readCString();
            if (ret_cstr) {
                logWriteLn(`[调用1] [frida] outArg_CharBuffer=[${ret_cstr}], ret_str.length=${ret_cstr.length}`);
                // [调用1] [frida] outArg_CharBuffer=[name:Zhangsan,id:4.000000,pi:17;zzzzzzzzzzzzz,hex:63,job_cnt:5,msg:hello_world,], ret_str.length=79
                //  结果正确
            }
        }
        //第2次调用
        func04_ret_code = nativeFn__func04_retVoid_outArgCharBuffer(-90909.2, -70070, outArg_CharBuffer);
        logWriteLn(`[调用2] func04_ret_code=${func04_ret_code}`);
        // [调用2] func04_ret_code=0
        if (func04_ret_code == _OK) {
            const ret_cstr = outArg_CharBuffer.readCString();
            if (ret_cstr) {
                logWriteLn(`[调用2] [frida] outArg_CharBuffer=[${ret_cstr}], ret_str.length=${ret_cstr.length}`);
                // [调用2] [frida] outArg_CharBuffer=[name:Zhangsan,id:-90909.200000,pi:-70070;zzzzzzzzzzzzz,hex:63,job_cnt:5,msg:hello_world,], ret_str.length=88
                //  结果正确
            }
        }
    } //end of if
}
const M_ascii = 'M'.charCodeAt(0);
/**  OnLeave ，函数离开
 */
function OnFnLeaveBusz(thiz, retval) {
    const curThreadId = Process.getCurrentThreadId();
    const fnAdr = thiz.context.pc;
    const fnSym = findFnDbgSym(fnAdr);
    if (fnAdr.readInt() != thiz.fnAdr_OnFnEnterBusz.readInt()) {
        logWriteLn(`##错误，进出函数地址不同`);
    }
    logWriteLn(`[OnFnLeaveBusz],fnSym=[${fnSym}]`);
    //调用本地函数 func01_return_int
    demo_call_nativeFn_func01();
    //调用本地函数 func03_retVoid_outArgPtrStructUser
    demo_call_nativeFn_func03();
    //调用本地函数 func04_retVoid_outArgCharBuffer
    demo_call_nativeFn_func04();
} //end of OnFnLeaveBusz
// '包装' 使用了  '实现' 和 '配置'
// '配置' 使用了  '实现'
// 导入 '模块的函数名过滤器 实现 '
//MyTsCRst//_replaceCurLineByTsFileContent("./_focus_fnAdr/_impl.ts" , curNextLn)
// [描述] 模块的函数名过滤器 实现
// [依赖] : 无
// [术语] : focuse == 关注,  not_focuse == 不关注 == 讨厌, include == 包含, exclude == 排除
//            包含 对应 关注, 
//            排除 对应 不关注
/**
ldd /app/可执行elf文件路径
        linux-vdso.so.1 (0x00007ffff7fc1000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007ffff6323000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff60fa000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fc3000)
        libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007ffff608a000)
        其他被依赖的so们
*/
//默认行文枚举: 包括 或 排除
var MG_Enum_DefaultAct;
(function (MG_Enum_DefaultAct) {
    // 包括 
    //   包含 对应 关注
    MG_Enum_DefaultAct[MG_Enum_DefaultAct["Include"] = 1] = "Include";
    // 排除
    //   排除 对应 讨厌
    MG_Enum_DefaultAct[MG_Enum_DefaultAct["Exclude"] = 2] = "Exclude";
})(MG_Enum_DefaultAct || (MG_Enum_DefaultAct = {}));
const MG_Enum_DefaultAct__Values = [MG_Enum_DefaultAct.Exclude, MG_Enum_DefaultAct.Include];
//断言是合法枚举
function assertIsValidEnum_DefaultAct(defaultAct) {
    if (!MG_Enum_DefaultAct__Values.includes(defaultAct)) {
        throw new Error(`[枚举量取值不合法] defaultAct[${defaultAct}] , 而MG_Enum_DefaultAct允许的列表为{${MG_Enum_DefaultAct__Values}}`);
    }
}
//关注==不讨厌
const _FOCUS = true;
//讨厌==不关注
const _NOT_FOCUS = false;
class MG_ModuleFilter {
    //关注该模块中的一些函数
    static build_includeFuncLs(moduleName, fnNameLs_include) {
        return new MG_ModuleFilter(moduleName, MG_Enum_DefaultAct.Include, fnNameLs_include, []);
    }
    //讨厌该模块中的一些函数
    static build_excludeFuncLs(moduleName, fnNameLs_exclude) {
        return new MG_ModuleFilter(moduleName, MG_Enum_DefaultAct.Exclude, [], fnNameLs_exclude);
    }
    //讨厌该模块中的全部函数
    static build_excludeAllFunc(moduleName) {
        return new MG_ModuleFilter(moduleName, MG_Enum_DefaultAct.Exclude, [], []);
    }
    //给定模块们, 讨厌任意一个模块的全部函数
    static build_excludeAllFunc_moduleLs(moduleName_ls) {
        const filterLs = moduleName_ls.map((moduleNameK) => {
            return MG_ModuleFilter.build_excludeAllFunc(moduleNameK);
        });
        return filterLs;
    }
    //关注该模块中的全部函数
    static build_includeAllFunc(moduleName) {
        return new MG_ModuleFilter(moduleName, MG_Enum_DefaultAct.Include, [], []);
    }
    //给定模块们, 关注任意一个模块的全部函数
    static build_includeAllFunc_moduleLs(moduleName_ls) {
        const filterLs = moduleName_ls.map((moduleNameK) => {
            return MG_ModuleFilter.build_includeAllFunc(moduleNameK);
        });
        return filterLs;
    }
    constructor(moduleName, defaultAct, fnNameLs_include, fnNameLs_exclude) {
        //断言是合法枚举
        assertIsValidEnum_DefaultAct(defaultAct);
        this.moduleName = moduleName;
        this.defaultAct = defaultAct;
        this.fnNameLs_include = fnNameLs_include;
        this.fnNameLs_exclude = fnNameLs_exclude;
    }
    focus(fnAdr) {
        const fnSym = DebugSymbol.fromAddress(fnAdr);
        const fnName = fnSym.name;
        const moduleName = fnSym.moduleName;
        if (moduleName == null) {
            throw new Error(`[该函数地址无模块名错误][疑似无该函数] DebugSymbol查找到 函数地址[${fnAdr}] 的moduleName为null`);
        }
        if (this.moduleName == null) {
            throw new Error(`[该过滤器无模块名错误]  [this] ${JSON.stringify(this)}`);
        }
        // console.log(`typeof(moduleName)=${typeof(moduleName)}, typeof(this.moduleName)=${typeof(this.moduleName)},, ${this.moduleName} == ${moduleName}:: ${this.moduleName == moduleName}`)
        if (this.moduleName != moduleName) {
            throw new Error(`[入参错误][疑似上层算法错误]   函数地址[${fnAdr}] 的moduleName[${moduleName}] 不等于 本MG_Module的moduleName[${this.moduleName}]`);
        }
        //讨厌名为空的函数
        if (fnName == null || fnName == undefined) {
            logWriteLn(`##讨厌名为空的函数.fnAdr=[${fnAdr}]`);
            return _NOT_FOCUS;
        }
        //默认动作 若为包含, 则关注
        if (this.defaultAct == MG_Enum_DefaultAct.Include) {
            //关注 包含函数名们
            const __focus = this.fnNameLs_include.includes(fnName);
            return __focus;
        }
        //默认动作 若为排除, 则讨厌
        else if (this.defaultAct == MG_Enum_DefaultAct.Exclude) {
            //讨厌 排除函数名们
            const __focus = (!this.fnNameLs_exclude.includes(fnName));
            return __focus;
        }
        else {
            //断言是合法枚举
            assertIsValidEnum_DefaultAct(this.defaultAct);
        }
        throw new Error(`[不应该能走到MG_Module.focus函数的最末尾][自身逻辑错误]   函数地址[${fnAdr}] ,json(fnSym)[${JSON.stringify(fnSym)}] , json(this)[${JSON.stringify(this)}]`);
    }
}
;
// 导入 '模块的函数名过滤器 配置 '
//MyTsCRst//_replaceCurLineByTsFileContent("./_focus_fnAdr/_config.ts" , curNextLn)
// [描述] 模块的函数名过滤器 配置
// [依赖] : g_appName
// [术语] :  参考 _focus_fnAdr/_impl.ts
//关注其所有函数的模块(暂无)
const _modules_include = [
    "other_module_1.so",
];
// "libstdc++.so.6.0.30", //?如果libstdc++的代码 穿插在业务代码中， 若忽略之 则调用链条断裂
// ldd /fridaAnlzAp/frida_js_demo/app.elf  | awk '{print " \""$1"\","}'
//讨厌其所有函数的模块
const _modules_exclude = [
    // "frida-agent-64.so",
    "linux-vdso.so.1",
    "libc.so.6",
    "/lib64/ld-linux-x86-64.so.2",
];
// objdump --syms /app2/sleuthkit/tools/autotools/tsk_recover  2>/dev/null | grep " F" | egrep -i "varLs|TL_TmPnt"  | awk '{print " \""$6"\","}'
/*去掉awk输出如下
0000000000122610 l     F .text	0000000000000095              _ZSt10accumulateIN9__gnu_cxx17__normal_iteratorIP9__VarDeclSt6vectorIS2_SaIS2_EEEES2_Z24destroyVarLs_inFn__RtCxxP11__VarDeclLsE3$_0ET0_T_SC_SB_T1_
00000000001226b0 l     F .text	00000000000000a5              _ZSt8for_eachIN9__gnu_cxx17__normal_iteratorIP9__VarDeclSt6vectorIS2_SaIS2_EEEEZ24destroyVarLs_inFn__RtCxxP11__VarDeclLsE3$_1ET0_T_SC_SB_
0000000000122760 l     F .text	0000000000000062              _ZZ24destroyVarLs_inFn__RtCxxP11__VarDeclLsENK3$_0clERK9__VarDeclS4_
00000000001227d0 l     F .text	0000000000000197              _ZZ24destroyVarLs_inFn__RtCxxP11__VarDeclLsENK3$_1clE9__VarDecl
0000000000121e80 g     F .text	00000000000000b0              _Z23_init_varLs_inFn__RtCxxNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES4_ii
00000000001216f0 g     F .text	000000000000004a              TL_TmPnt__update
000000000011e480 g     F .text	0000000000000079              _init_varLs_inFn__RtC00
0000000000121740 g     F .text	0000000000000018              TL_TmPnt__get
000000000011e580 g     F .text	000000000000016f              destroyVarLs_inFn__RtC00
0000000000121760 g     F .text	0000000000000037              TL_TmPnt__printPtr
0000000000121fd0 g     F .text	0000000000000632              _Z24destroyVarLs_inFn__RtCxxP11__VarDeclLs
*/
const _moduleApp__clangVar_runtime_fnNameLs = [
    "_ZSt10accumulateIN9__gnu_cxx17__normal_iteratorIP9__VarDeclSt6vectorIS2_SaIS2_EEEES2_Z24destroyVarLs_inFn__RtCxxP11__VarDeclLsE3$_0ET0_T_SC_SB_T1_",
    "_ZSt8for_eachIN9__gnu_cxx17__normal_iteratorIP9__VarDeclSt6vectorIS2_SaIS2_EEEEZ24destroyVarLs_inFn__RtCxxP11__VarDeclLsE3$_1ET0_T_SC_SB_",
    "_ZZ24destroyVarLs_inFn__RtCxxP11__VarDeclLsENK3$_0clERK9__VarDeclS4_",
    "_ZZ24destroyVarLs_inFn__RtCxxP11__VarDeclLsENK3$_1clE9__VarDecl",
    "_Z23_init_varLs_inFn__RtCxxNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES4_ii",
    "TL_TmPnt__update",
    "_init_varLs_inFn__RtC00",
    "TL_TmPnt__get",
    "destroyVarLs_inFn__RtC00",
    "TL_TmPnt__printPtr",
    "_Z24destroyVarLs_inFn__RtCxxP11__VarDeclLs",
];
const _moduleApp__exclude_fnNameLs = [
    //跳过被frida调用的本地函数
    "func01_return_int",
    "func03_retVoid_outArgPtrStructUser",
    "func04_retVoid_outArgCharBuffer",
];
//本应用自身模块的函数名过滤器 
//    排除clang-var插件的运行时的函数们、排除调用量很大的函数们
const _appFilter = MG_ModuleFilter.build_excludeFuncLs(g_appName, [..._moduleApp__clangVar_runtime_fnNameLs, ..._moduleApp__exclude_fnNameLs]);
const _moduleFilterLs = [_appFilter];
// 之后 _wrap.ts 中 组装出 最终使用的过滤器 mg_moduleFilter_ls  如下所示 
/*
const mg_moduleFilter_ls: MG_ModuleFilter[]=[
  ..._moduleFilterLs, //一般模块过滤器们
  ..._modules_exclude, //讨厌其所有函数的模块
  ..._modules_include //关注其所有函数的模块
];
 */
// 导入 '模块的函数名过滤器 包装 '
//MyTsCRst//_replaceCurLineByTsFileContent("./_focus_fnAdr/_wrap.ts" , curNextLn)
// [描述] 模块的函数名过滤器 包装
// [依赖] : g_appName
// [术语] :  参考 _focus_fnAdr/_impl.ts
const mg_moduleFilter_ls = [
    //一般模块过滤器们
    ..._moduleFilterLs,
    //讨厌其所有函数的模块
    //   linux操作系统基础库、本应用调用的一些不需要关注的库
    ...MG_ModuleFilter.build_excludeAllFunc_moduleLs(_modules_exclude),
    //关注其所有函数的模块
    //   实际没有这样的模块
    ...MG_ModuleFilter.build_includeAllFunc_moduleLs(_modules_include)
];
//构造 以模块名查找过滤器 的 查找表
const mg_moduleFilter_searchByModuleName = mg_moduleFilter_ls.reduce(
//reduce的函数1: 迭代函数
(_dict, moduleFilterK) => {
    _dict[moduleFilterK.moduleName] = moduleFilterK;
    return _dict;
}, {} //reduce的函数2:  初始字典
);
// console.log(`mg_moduleFilter_ls=${mg_moduleFilter_ls} `);
// console.log(`mg_moduleFilter_ls.keys=  ${mg_moduleFilter_ls.keys()}`);
// const _keys=mg_moduleFilter_ls.keys();
// console.log(`mg_moduleFilter_ls.JSON=  ${JSON.stringify(mg_moduleFilter_ls)}`);

// console.log(`mg_moduleFilter_searchByModuleName.JSON=  ${JSON.stringify(mg_moduleFilter_searchByModuleName)}`);
//是否关注该函数
function focus_fnAdr(fnAdr) {
    const fnSym = DebugSymbol.fromAddress(fnAdr);
    // logWriteLn(`[json(fnSym)]: ${JSON.stringify(fnSym)}`);
    console.log(`fnSym.json= ${JSON.stringify(fnSym)}`);
    const moduleName = fnSym.moduleName;
    if (moduleName == null) {
        throw new Error(`[focus_fnAdr:函数地址的模块名为空错误] fnAdr[${fnAdr}] `);
    }
    //查找该模块的函数名过滤器
    const moduleFilter = mg_moduleFilter_searchByModuleName[moduleName];
    if(moduleFilter==null){
        return false;
    }
    console.log(`typeof(moduleFilter) = ${typeof(moduleFilter)}`);
    //执行该过滤器, 获得是否关注本函数
    const _focus = moduleFilter.focus(fnAdr);
    return _focus;
}
function _main_() {
    //获取本地函数 func01_return_int
    get__func01_return_int();
    //获取 本地函数 func03_retVoid_outArgPtrStructUser
    get__func03_retVoid_outArgPtrStructUser();
    //获取 本地函数 func04_retVoid_outArgCharBuffer
    get__func04_retVoid_outArgCharBuffer();
    const fnAdrLs = DebugSymbol.findFunctionsMatching("*");
    logWriteLn(`fnAdrLs.length=${fnAdrLs.length}`);
    const fnAdrCnt = fnAdrLs.length;
    for (let [k, fnAdr] of fnAdrLs.entries()) {
        if (!focus_fnAdr(fnAdr)) {
            continue;
        }
        const fnSym = DebugSymbol.fromAddress(fnAdr);
        logWriteLn(`[对函数做Interceptor.attach] ${fnAdr}, ${fnSym}`);
        Interceptor.attach(fnAdr, {
            onEnter: function (args) {
                OnFnEnterBusz(this, args);
            },
            onLeave: function (retval) {
                OnFnLeaveBusz(this, retval);
            }
        });
    }
}
/**
frida 运行报超时错误 "Failed to load script: timeout was reached" 解决
frida 运行报超时错误 "Failed to load script: the connection is closed" 解决

错误的解决办法： 命令行加选项timeout  'frida --timeout 0或-1或很大的数 --file ... '

正确的解决办法是，像下面这样  用 函数setTimeout(... , 0) 包裹 业务代码
 */
// frida  https://github.com/frida/frida/issues/113#issuecomment-187134331
setTimeout(function () {
    //业务代码
    _main_();
}, 0);
